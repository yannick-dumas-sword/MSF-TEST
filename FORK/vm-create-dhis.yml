#############################################################
####################### VM DEPLOYMENT #######################
#############################################################

- name: Deploy DHIS VM on Hyper-V
  hosts: "{{ lookup('env', 'code_projet') }}PHYP001P"
  gather_facts: no

  vars:
    #VM definition
    default_generation: 2
    cpu: 4
    memory: 4096MB

    #Switch definition
    network_switch: 'SW-1G'
    
    #ISO definition
    src_iso: 'C:\Fiwi_IT_TEST\Iso\FINAL.iso'
    
    #VHDX naming and sizing
    vhdx_suffixes:
      #/var
      - name: 'VAR'
        size: '20GB'
      #/var/log
      - name: 'VARLOG'
        size: '10GB'
      #/home    
      - name: 'HOME'
        size: '10GB'
      #/home/dhis2
      - name: 'DHIS2'
        size: '10GB'
      #home/bckp
      - name: 'BCKP'
        size: '10GB'
        
    #VHDX location
    vhdx_location:
      - 'C:\ClusterStorage\Volume1\Hyper-V\DHIS'
      
    #Network parameters
    network:
      ip_start: 150
      ip_end: 159
      subnet_mask: '255.255.255.0'
      gateway: "{{ subnet }}.1"
      dns:
        - "{{ subnet }}.1"
        - '8.8.8.8'
        
    #Hyper-V
    hyperv_suffix: "PHYP001P"
    dhcp_suffix: "VDCRO001P"
    
    #VM Type
    vm_type: "DHIS"    
       
  #Let's goooooooo
  tasks:
    #First we check the IP range
    - name: Check IP range of the host
      set_fact:
        subnet: "{{ lookup('dig', inventory_hostname).split('.')[0] + '.' + lookup('dig', inventory_hostname).split('.')[1] + '.' + lookup('dig', inventory_hostname).split('.')[2] }}"
  
    #We look at existings VMs regarding our environment variables by checking the host
    #We register our future VM's name as a variable "next_vm_number" for the current playbook
    - name: Determine next available VM name (based on env)
      win_shell: |
        $code_projet = "{{ lookup('env', 'code_projet') }}"
        $type_machine = "{{ vm_type }}"
        $environnement = "{{ lookup('env', 'environment') }}"

        $regex = "^${code_projet}V${type_machine}(\d+)$environnement$"
        $vm_names = Get-VM | Select-Object -ExpandProperty Name
        $vm_numbers = $vm_names | ForEach-Object { if ($_ -match $regex) { [int]$matches[1] } } | Sort-Object
        $next_vm_number = 1
        foreach ($number in $vm_numbers) {
          if ($number -gt $next_vm_number) { break }
          $next_vm_number += 1
        }
        $next_vm_number.ToString("D3")
      register: next_vm_number
      
    # We check for the next available IP based on playbook defined range ()
    - name: Determine first available IP (based on host)
      win_shell: |
        $ipStart = {{ network.ip_start }}
        $ipEnd = {{ network.ip_end }}
        $subnet = "{{ subnet }}" # Using the previously set subnet variable
        for ($i=$ipStart; $i -le $ipEnd; $i++) {
            $ip = $subnet + "." + $i
            if (!(Test-Connection -ComputerName $ip -Count 1 -Quiet)) {
                return $ip
            }
        }
        throw "No free IP address found in the specified range."
      register: free_ip
      
    - name: INFO (VM and IP)
      debug:
        msg: "IP will be {{ free_ip.stdout | trim }}" 
        msg: "Next VM name will be {{ lookup('env', 'code_projet') }}V{{ vm_type }}{{ next_vm_number.stdout | trim }}{{ lookup('env', 'environment') }}" 
    
    - name: Make sure .vhdx files don't exist already
      win_shell: |
        $vm_name = '{{ lookup('env', 'code_projet') }}V{{ vm_type }}{{ next_vm_number.stdout | trim }}{{ lookup('env', 'environment') }}'
        $suffix = "{{ item.name }}"
        $path = "C:\\ClusterStorage\\Volume1\\Hyper-V\\DHIS\\${vm_name}-${suffix}.vhdx"

        if (Test-Path -Path $path) {
          throw "File $path already exists."
        }
      with_items: "{{ vhdx_suffixes }}"
      register: vhdx_check_result
      failed_when: vhdx_check_result.stderr != ""

    
    - name: Check if the IP reservation or lease already exists
      win_shell: |
        $password = "{{ lookup('env', 'p') }}" | ConvertTo-SecureString -AsPlainText -Force
        $credential = New-Object System.Management.Automation.PSCredential ('{{ lookup('env', 'u') }}', $password)
        $subnet = "{{ subnet }}.0"
        $ipaddress = "{{ free_ip.stdout | trim }}"

        $scriptBlock = {
          param($subnet, $ipaddress)
          
          # Check for existing reservation
          $reservation = Get-DhcpServerv4Reservation -ScopeId $subnet -IPAddress $ipaddress -ErrorAction SilentlyContinue
          if ($reservation) {
            throw "Reservation already exists for IP $ipaddress in subnet $subnet."
          }

          # Check for existing lease
          $lease = Get-DhcpServerv4Lease -ScopeId $subnet -IPAddress $ipaddress -ErrorAction SilentlyContinue
          if ($lease) {
            throw "Lease already exists for IP $ipaddress in subnet $subnet."
          }
        }

        Invoke-Command -ComputerName {{ lookup('env', 'code_projet') }}VRODC001P -ScriptBlock $scriptBlock -ArgumentList $subnet, $ipaddress
      register: ip_check_result
      failed_when: ip_check_result.stderr != ""


    
    
    
    
    
    
    
    #We create the VM and power it for 10 seconds so the vnet card gets initialized and obtains a MAC address from host. We save the MAC address.
    - name: VM Creation ({{ lookup('env', 'code_projet') }}V{{ vm_type }}{{ next_vm_number.stdout | trim }}{{ lookup('env', 'environment') }})
      win_shell: |
        $vm_name = '{{ lookup('env', 'code_projet') }}V{{ vm_type }}{{ next_vm_number.stdout | trim }}{{ lookup('env', 'environment') }}'
        $vm = Get-VM -Name $vm_name
        if ($null -eq $vm) {
          $vm = New-VM -Name $vm_name -Generation {{ default_generation }} -MemoryStartupBytes {{ memory }} -SwitchName {{ network_switch }}
          Set-VMProcessor -VM $vm -Count {{ cpu }}
          Start-VM -Name $vm_name # Start the VM
          # Start VM so network card gets a MAC address ----------------------- ANSIBLE COMMENT
          Start-Sleep -Seconds 1
          Stop-VM -TurnOff -Name $vm_name
          # --- and turn off after 1 seconds --------------------------------- ANSIBLE COMMENT
        }                
        $vm.NetworkAdapters[0].MacAddress
      register: mac_address

############################DOUBLE QUOTES OBLIGATOIRES ?######################
######Sinon {{ vhdx_location }} =       - 'C:\ClusterStorage\Volume1\Hyper-V\DHIS'#######
    - name: Create and attach OS VHDX
      win_shell: |
        $vm_name = '{{ lookup('env', 'code_projet') }}V{{ vm_type }}{{ next_vm_number.stdout | trim }}{{ lookup('env', 'environment') }}'
        $path = "C:\\ClusterStorage\\Volume1\\Hyper-V\\DHIS\\${vm_name}-OS.vhdx"
        if (-not (Test-Path $path)) {
          New-VHD -Path $path -Dynamic -SizeBytes 15GB
        }
        $vm = Get-VM -Name $vm_name
        if ($null -ne $vm) {
          $existingVhd = Get-VMHardDiskDrive -VMName $vm.Name | Where-Object { $_.Path -eq $path }
          if ($existingVhd -eq $null) {
            Add-VMHardDiskDrive -VM $vm -Path $path
          }
        }          
      register: vhdx_exists

    # We pre-register amongst the local RODC especially for DNS
    - name: Local RODC DHCP+DNS pre-registration
      win_shell: |
        $password = "{{ lookup('env', 'p') }}" | ConvertTo-SecureString -AsPlainText -Force
        $credential = New-Object System.Management.Automation.PSCredential ('{{ lookup('env', 'u') }}', $password)
        $subnet = "{{ subnet }}.0" # Removed quotes around 'subnet'
        $name = "{{ lookup('env', 'code_projet') }}V{{ vm_type }}{{ next_vm_number.stdout | trim }}{{ lookup('env', 'environment') }}.ocg.msf.org"
        $ipaddress = "{{ free_ip.stdout | trim }}"
        $clientid = "{{ mac_address.stdout | trim }}" # Changed variable name

        $scriptBlock = {
          param($subnet, $name, $ipaddress, $clientid) # Changed parameter name
          Add-DhcpServerv4Reservation -ScopeID $subnet -Name $name -IPAddress $ipaddress -ClientId $clientid
        }

        Invoke-Command -ComputerName {{ lookup('env', 'code_projet') }}VRODC001P -Credential $credential -ScriptBlock $scriptBlock -ArgumentList $subnet, $name, $ipaddress, $clientid
        
    #Disabling secure boot before custom ISO install
    - name: Disable secure boot
      win_shell: |
        $vm_name = "{{ lookup('env', 'code_projet') }}V{{ vm_type }}{{ next_vm_number.stdout | trim }}{{ lookup('env', 'environment') }}"
        Set-VMFirmware -EnableSecureBoot Off -VMName $vm_name

    #Attach ISO to DVD
    - name: Attach ISO to VM
      win_shell: |
        $vm_name = "{{ lookup('env', 'code_projet') }}V{{ vm_type }}{{ next_vm_number.stdout | trim }}{{ lookup('env', 'environment') }}"
        $vm = Get-VM -Name $vm_name
        $dvdDrive = Get-VMDvdDrive -VM $vm | Where-Object { $_.ControllerLocation -eq "0" }
        if ($dvdDrive -ne $null)
        {
            Set-VMDvdDrive -VM $vm -ControllerNumber $dvdDrive.ControllerNumber -ControllerLocation $dvdDrive.ControllerLocation -Path "{{ src_iso }}"
        }
        else
        {
            try {
                Add-VMDvdDrive -VM $vm -ControllerNumber 0 -ControllerLocation 1 -Path "{{ src_iso }}"
            } catch {
                Write-Error "Failed to add DVD Drive: $_"
            }
        }                

    #Booting on defined ISO
    - name: Set VM to boot from DVD Drive
      win_shell: |
        $vm_name = '{{ lookup('env', 'code_projet') }}V{{ vm_type }}{{ next_vm_number.stdout | trim }}{{ lookup('env', 'environment') }}'
        $vm = Get-VM -Name {{ lookup('env', 'code_projet') }}V{{ vm_type }}{{ next_vm_number.stdout | trim }}{{ lookup('env', 'environment') }}
        $dvdDrive = Get-VMDvdDrive -VM $vm
        Set-VMFirmware -VM $vm -FirstBootDevice $dvdDrive                

    #Enable LIS... Why do I even comment
    - name: Enable Linux Integration Services
      win_shell: |
        $vm_name = '{{ lookup('env', 'code_projet') }}V{{ vm_type }}{{ next_vm_number.stdout | trim }}{{ lookup('env', 'environment') }}'
        Enable-VMIntegrationService -VMName $vm_name -Name 'Guest Service Interface'       

    #We power on the VM and wait for it to get an IP at the end of the autoinstall
    - name: ~30min | Power on and wait OS autoinstall...
      win_shell: |
        $vm_name = '{{ lookup('env', 'code_projet') }}V{{ vm_type }}{{ next_vm_number.stdout | trim }}{{ lookup('env', 'environment') }}'
        $vm = Get-VM -Name $vm_name
         if ($vm.State -eq 'Off') {
           Start-VM -VM $vm
         }                
        $vm = Get-VM -Name $vm_name
        do {
          Start-Sleep -Seconds 10
          $vm = Get-VM -Name $vm_name
          $ip = ($vm.NetworkAdapters.IPAddresses | Where-Object { $_ -like "*.*.*.*" })[0]
        } while ($ip -eq $null)
        Write-Output $ip                        
      register: vm_ip

    #Shutting down the VM to make some adjustments
    - name: OS deployed, shutting down to configure Hyper-V
      win_shell: |
        $vm_name = '{{ lookup('env', 'code_projet') }}V{{ vm_type }}{{ next_vm_number.stdout | trim }}{{ lookup('env', 'environment') }}'
        $vm = Get-VM -Name $vm_name
        if ($vm.State -ne 'Off') {
          Stop-VM -VM $vm -Force
        }         

    #Secure boot
    - name: Enable Secure Boot
      win_shell: |
        $vm_name = '{{ lookup('env', 'code_projet') }}V{{ vm_type }}{{ next_vm_number.stdout | trim }}{{ lookup('env', 'environment') }}'
        Set-VMFirmware -VMName $vm_name -EnableSecureBoot On -SecureBootTemplate 'MicrosoftUEFICertificateAuthority'

    #TPM
    - name: Enable TPM
      win_shell: |
        Import-Module Hyper-V
        $vm = Get-VM -Name "{{ lookup('env', 'code_projet') }}V{{ vm_type }}{{ next_vm_number.stdout | trim }}{{ lookup('env', 'environment') }}"
        $vm | Set-VMKeyProtector -NewLocalKeyProtector
        $vm | Enable-VMEncryption
        Enable-VMTPM -VMName "{{ lookup('env', 'code_projet') }}V{{ vm_type }}{{ next_vm_number.stdout | trim }}{{ lookup('env', 'environment') }}"
      args:
        executable: powershell

    #Power on
    - name: Power on VM
      win_shell: |
        $vm_name = "{{ lookup('env', 'code_projet') }}V{{ vm_type }}{{ next_vm_number.stdout | trim }}{{ lookup('env', 'environment') }}"
        $vm = Get-VM -Name $vm_name
        if ($vm.State -eq 'Off') {
          Start-VM -VM $vm
        }

    #Pause to make sure everyting's up
    - name: Wait 1 minute to make sure VM fully booted up
      pause:
        minutes: 1

    #Network configuration over Hyper-V
    - name: Configure network
      win_shell: |
        $vm_name = '{{ lookup('env', 'code_projet') }}V{{ vm_type }}{{ next_vm_number.stdout | trim }}{{ lookup('env', 'environment') }}'
        Get-VMNetworkAdapter -VMName $vm_name | Set-VMNetworkConfiguration -IPAddress {{ free_ip.stdout | trim }} -Subnet {{ network.subnet_mask }} -DNSServer {{ network.dns|join(",") }} -DefaultGateway {{ network.gateway }}

    #Additional storage configuration
    
############################DOUBLE QUOTES OBLIGATOIRES ?######################
######Sinon {{ vhdx_location }} =       - 'C:\ClusterStorage\Volume1\Hyper-V\DHIS'#######
    
    - name: Create and attach additional VHDX
      win_shell: |
        $vm_name = '{{ lookup('env', 'code_projet') }}V{{ vm_type }}{{ next_vm_number.stdout | trim }}{{ lookup('env', 'environment') }}'
        $vm = Get-VM -Name $vm_name
        $suffix = "{{ item.name }}"
        $path = "C:\\ClusterStorage\\Volume1\\Hyper-V\\DHIS\\${vm_name}-${suffix}.vhdx"
        $sizeGB = "{{ item.size[:-2] }}"
        $size = [int64]$sizeGB * 1GB
        if (-not (Test-Path $path)) {
          New-VHD -Path $path -Dynamic -SizeBytes $size
        }
        $existingVhd = Get-VMHardDiskDrive -VMName $vm.Name | Where-Object { $_.Path -eq $path }
        if ($existingVhd -eq $null) {
          Add-VMHardDiskDrive -VM $vm -Path $path
        }                
      loop: "{{ vhdx_suffixes }}"

    #Boot media removal
    - name: Remove DVD drive from VM
      win_shell: |
        $vm_name = '{{ lookup('env', 'code_projet') }}V{{ vm_type }}{{ next_vm_number.stdout | trim }}{{ lookup('env', 'environment') }}'
        $vm = Get-VM -Name $vm_name
        $dvdDrive = Get-VMDvdDrive -VM $vm
        if ($dvdDrive -ne $null)
        {
            $dvdDrive | Remove-VMDvdDrive -Confirm:$false
            Write-Output "DVD drive removed from the VM."
        }
        
    #Shutting down the VM to make some adjustments
#    - name: Shut down
#      win_shell: |
#        $vm_name = '{{ lookup('env', 'code_projet') }}V{{ vm_type }}{{ next_vm_number.stdout | trim }}{{ lookup('env', 'environment') }}'
#        $vm = Get-VM -Name $vm_name
#        if ($vm.State -ne 'Off') {
#          Stop-VM -VM $vm -Force
#        }  
#        
    #Final DHCP entry update
    - name: Update RODC DHCP entry name
      win_shell: |
        $password = "{{ lookup('env', 'p') }}" | ConvertTo-SecureString -AsPlainText -Force
        $credential = New-Object System.Management.Automation.PSCredential ('{{ lookup('env', 'u') }}', $password)
        $vm_name = "{{ lookup('env', 'code_projet') }}V{{ vm_type }}{{ next_vm_number.stdout | trim }}{{ lookup('env', 'environment') }}.ocg.msf.org"
        $ipaddress = "{{ free_ip.stdout | trim }}"

        $scriptBlock = {
          param($vm_name, $ipaddress)
          Set-DhcpServerv4Reservation -IPAddress $ipaddress -Name $vm_name
        }
        Invoke-Command -ComputerName GCH001VRODC001P -Credential $credential -ScriptBlock $scriptBlock -ArgumentList $vm_name, $ipaddress
        
    #VM deployed
    - name: INFO | Deployment done
      debug:
        msg: "Machine name is {{ lookup('env', 'code_projet') }}V{{ vm_type }}{{ next_vm_number.stdout | trim }}{{ lookup('env', 'environment') }} and IP address is {{ free_ip.stdout | trim }}"
        
    - name: Registering facts for VM configuration
      set_fact:
        vm_name: "{{ lookup('env', 'code_projet') }}V{{ vm_type }}{{ next_vm_number.stdout | trim }}{{ lookup('env', 'environment') }}"
        ip_address: "{{ free_ip.stdout | trim }}"
      
    - name: Creating dynamic Ansible host for the VM
      add_host:
        name: "{{ ip_address }}"
        groups: new_vm_host
        ansible_ssh_extra_args: '-o StrictHostKeyChecking=no'
        ansible_user: "{{ lookup('env', 'vm_user') }}"
        ansible_password: "{{ lookup('env', 'vm_pass') }}"
        ansible_sudo_pass: "{{ lookup('env', 'vm_pass') }}"
      vars:
        ansible_remote_tmp: /tmp/.ansible/tmp
        






#############################################################
##################### VM CONFIGURATION ######################
#############################################################

- name: Configure DHIS VM
  hosts: new_vm_host
  become: true
  gather_facts: true
  vars:
    public_keys_file: /SSH_Keys/ssh_dhis
    
#    users:
#      - name: adrian
#        ssh_key: /SSH_Keys/Adrian.pub
#      - name: arnau
#        ssh_key: /SSH_Keys/Arnau.pub
#      - name: hawizi
#        ssh_key: /SSH_Keys/Hawizi.pub
#      - name: nazar
#        ssh_key: /SSH_Keys/Nazar.pub
#      - name: nicolas
#        ssh_key: /SSH_Keys/Nicolas.pub
#      - name: yann
#        ssh_key: /SSH_Keys/Yann.pub
        
    devices:
      - { device: '/dev/sdb', mount: '/var', temp_mount: '/mnt/var' }
      - { device: '/dev/sdc', mount: '/var/log', temp_mount: '/mnt/varlog' }
      - { device: '/dev/sdd', mount: '/home', temp_mount: '/mnt/home' }
      - { device: '/dev/sde', mount: '/home/dhis2', temp_mount: '/mnt/dhis2' }
      - { device: '/dev/sdf', mount: '/home/backup', temp_mount: '/mnt/backup' }
        
  tasks:
    - name: Set hostname to match inventory hostname
      hostname:
        name: "{{ vm_name }}"
        
    - name: Create dhis2 user
      user:
        name: dhis2
        home: /home/dhis2
        shell: /bin/false
        create_home: yes

    - name: Create backup user
      user:
        name: backup
        home: /home/backup
        shell: /bin/false
        create_home: yes
 
    - name: Create ext4 filesystem on devices
      command: mkfs.ext4 {{ item.device }}
      loop: "{{ devices }}"
      loop_control:
        label: "{{ item.device }}"

    - name: Create temporary mount points
      file:
        path: "{{ item.temp_mount }}"
        state: directory
      loop: "{{ devices }}"

    - name: Mount devices to temporary mount points
      mount:
        path: "{{ item.temp_mount }}"
        src: "{{ item.device }}"
        fstype: ext4
        state: mounted
      loop: "{{ devices }}"

    - name: Synchronize directories
      command: rsync -a "{{ item.mount }}/." "{{ item.temp_mount }}"
      loop: "{{ devices }}"

    - name: Unmount temporary mount points
      mount:
        path: "{{ item.temp_mount }}"
        state: absent
      loop: "{{ devices }}"

    - name: Mount devices to final mount points
      mount:
        path: "{{ item.mount }}"
        src: "{{ item.device }}"
        fstype: ext4
        state: mounted
      loop: "{{ devices }}"
      
    - name: Update /etc/fstab
      shell: echo "UUID=$(blkid -s UUID -o value {{ item.device }}) {{ item.mount }} ext4 defaults 0 0" >> /etc/fstab
      loop: "{{ devices }}"

#    - name: Install necessary packages
#      apt:
        #name: ['openjdk-11-jdk', 'postgresql', 'postgresql-contrib', 'postgis', 'tomcat9']
#        name: ['openjdk-11-jdk']
#        state: present
#        update_cache: yes

    - name: Set root authorized_keys
      copy:
        src: "{{ public_keys_file }}"
        dest: "/root/.ssh/authorized_keys"
        owner: "root"
        group: "root"
        mode: '0600'

    - name: Disable password authentication
      lineinfile:
        dest: /etc/ssh/sshd_config
        regexp: '^#?PasswordAuthentication'
        line: 'PasswordAuthentication no'
        state: present
      notify: Restart ssh

    - name: Wipe known hosts
      file:
        path: /root/.ssh/known_hosts
        state: absent

  handlers:
    - name: Restart ssh
      service:
        name: ssh
        state: restarted